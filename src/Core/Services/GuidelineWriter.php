<?php

namespace FelipeReisDev\PhpBoost\Core\Services;

class GuidelineWriter
{
    private $rootPath;
    private $backupPath;

    public function __construct($rootPath, $backupPath = null)
    {
        $this->rootPath = rtrim($rootPath, '/');
        $this->backupPath = $backupPath ?: $this->rootPath . '/.php-boost-backups';
    }

    public function writeClaudeMd($content)
    {
        $filePath = $this->rootPath . '/CLAUDE.md';
        return $this->writeFile($filePath, $content, true);
    }

    public function writeAgentsMd($content)
    {
        $filePath = $this->rootPath . '/AGENTS.md';
        return $this->writeFile($filePath, $content, false);
    }

    public function writeFile($filePath, $content, $preserveCustomContent = true)
    {
        $existingContent = '';
        $fileExists = file_exists($filePath);

        if ($fileExists) {
            $existingContent = file_get_contents($filePath);
            $this->createBackup($filePath);
        }

        if ($preserveCustomContent && $fileExists) {
            $finalContent = $this->mergeContent($existingContent, $content);
        } else {
            $finalContent = $content;
        }

        $result = file_put_contents($filePath, $finalContent);

        if ($result === false) {
            throw new \RuntimeException("Failed to write file: {$filePath}");
        }

        return true;
    }

    private function mergeContent($existingContent, $newContent)
    {
        $autoGenStart = '<!-- AUTO-GENERATED by PHP Boost -->';
        $autoGenEnd = '<!-- END AUTO-GENERATED -->';

        $hasAutoGenSection = strpos($existingContent, $autoGenStart) !== false 
            && strpos($existingContent, $autoGenEnd) !== false;

        if (!$hasAutoGenSection) {
            return $newContent;
        }

        $pattern = '/' . preg_quote($autoGenStart, '/') . '.*?' . preg_quote($autoGenEnd, '/') . '/s';
        preg_match($pattern, $newContent, $newMatches);
        
        if (empty($newMatches[0])) {
            return $newContent;
        }

        $newAutoGenSection = $newMatches[0];
        $mergedContent = preg_replace($pattern, $newAutoGenSection, $existingContent, 1);

        return $mergedContent;
    }

    private function createBackup($filePath)
    {
        if (!file_exists($filePath)) {
            return false;
        }

        if (!is_dir($this->backupPath)) {
            mkdir($this->backupPath, 0755, true);
        }

        $filename = basename($filePath);
        $timestamp = date('Y-m-d_H-i-s');
        $backupFile = $this->backupPath . '/' . $filename . '.' . $timestamp . '.bak';

        $result = copy($filePath, $backupFile);

        if ($result) {
            $this->cleanOldBackups($filename);
        }

        return $result;
    }

    private function cleanOldBackups($filename, $keepLast = 5)
    {
        if (!is_dir($this->backupPath)) {
            return;
        }

        $backupFiles = glob($this->backupPath . '/' . $filename . '.*.bak');
        
        if (count($backupFiles) <= $keepLast) {
            return;
        }

        usort($backupFiles, function ($a, $b) {
            return filemtime($b) - filemtime($a);
        });

        $filesToDelete = array_slice($backupFiles, $keepLast);
        
        foreach ($filesToDelete as $file) {
            unlink($file);
        }
    }

    public function getBackupPath()
    {
        return $this->backupPath;
    }

    public function hasBackups($filename)
    {
        if (!is_dir($this->backupPath)) {
            return false;
        }

        $backupFiles = glob($this->backupPath . '/' . $filename . '.*.bak');
        
        return !empty($backupFiles);
    }

    public function getLatestBackup($filename)
    {
        if (!is_dir($this->backupPath)) {
            return null;
        }

        $backupFiles = glob($this->backupPath . '/' . $filename . '.*.bak');
        
        if (empty($backupFiles)) {
            return null;
        }

        usort($backupFiles, function ($a, $b) {
            return filemtime($b) - filemtime($a);
        });

        return $backupFiles[0];
    }
}
